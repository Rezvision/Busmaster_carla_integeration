/* This file is generated by BUSMASTER */
/* VERSION [1.2] */
/* BUSMASTER VERSION [3.2.2] */
/* PROTOCOL [CAN] */

/* Start BUSMASTER include header */
#include <windows.h>
#include "C:\BUSMASTER_v3.2.2\SimulatedSystems\include\CANIncludes.h"
/* End BUSMASTER include header */

/* Start BUSMASTER global variable */
CAN_steering steeringMsg;
int messageCount = 0;
/* End BUSMASTER global variable */

/* Dynamic loading of Winsock functions */
HMODULE hWs2_32 = NULL;
void* udpSocket = NULL;

/* Function pointer types */
typedef int (__stdcall *PFN_WSASTARTUP)(WORD, void*);
typedef int (__stdcall *PFN_WSACLEANUP)(void);
typedef void* (__stdcall *PFN_SOCKET)(int, int, int);
typedef int (__stdcall *PFN_CLOSESOCKET)(void*);
typedef int (__stdcall *PFN_BIND)(void*, const void*, int);
typedef int (__stdcall *PFN_RECVFROM)(void*, char*, int, int, void*, int*);
typedef int (__stdcall *PFN_IOCTLSOCKET)(void*, long, unsigned long*);
typedef unsigned short (__stdcall *PFN_HTONS)(unsigned short);

/* Function pointers */
PFN_WSASTARTUP pfnWSAStartup = NULL;
PFN_WSACLEANUP pfnWSACleanup = NULL;
PFN_SOCKET pfnSocket = NULL;
PFN_CLOSESOCKET pfnClosesocket = NULL;
PFN_BIND pfnBind = NULL;
PFN_RECVFROM pfnRecvfrom = NULL;
PFN_IOCTLSOCKET pfnIoctlsocket = NULL;
PFN_HTONS pfnHtons = NULL;

/* Custom sockaddr structure */
struct MySockAddr {
    short family;
    unsigned short port;
    unsigned long addr;
    char zero[8];
};

/* Start BUSMASTER Function Prototype */
GCC_EXTERN void GCC_EXPORT OnDLL_Load();
GCC_EXTERN void GCC_EXPORT OnDLL_Unload();
GCC_EXTERN void GCC_EXPORT OnTimer_steeringTransmit_10();
/* End BUSMASTER Function Prototype */

/* Initialize UDP Socket */
bool InitUDP()
{
    hWs2_32 = LoadLibrary("ws2_32.dll");
    if (!hWs2_32) {
        Trace("steering ECU: Failed to load ws2_32.dll");
        return false;
    }
    
    pfnWSAStartup = (PFN_WSASTARTUP)GetProcAddress(hWs2_32, "WSAStartup");
    pfnWSACleanup = (PFN_WSACLEANUP)GetProcAddress(hWs2_32, "WSACleanup");
    pfnSocket = (PFN_SOCKET)GetProcAddress(hWs2_32, "socket");
    pfnClosesocket = (PFN_CLOSESOCKET)GetProcAddress(hWs2_32, "closesocket");
    pfnBind = (PFN_BIND)GetProcAddress(hWs2_32, "bind");
    pfnRecvfrom = (PFN_RECVFROM)GetProcAddress(hWs2_32, "recvfrom");
    pfnIoctlsocket = (PFN_IOCTLSOCKET)GetProcAddress(hWs2_32, "ioctlsocket");
    pfnHtons = (PFN_HTONS)GetProcAddress(hWs2_32, "htons");
    
    if (!pfnWSAStartup || !pfnSocket || !pfnBind || !pfnRecvfrom) {
        Trace("steering ECU: Failed to get Winsock functions");
        FreeLibrary(hWs2_32);
        return false;
    }
    
    char wsaData[400];
    if (pfnWSAStartup(0x0202, wsaData) != 0) {
        Trace("steering ECU: WSAStartup failed");
        FreeLibrary(hWs2_32);
        return false;
    }
    
    udpSocket = pfnSocket(2, 2, 17);
    if (!udpSocket || udpSocket == (void*)-1) {
        Trace("steering ECU: Socket creation failed");
        pfnWSACleanup();
        FreeLibrary(hWs2_32);
        return false;
    }
    
    unsigned long mode = 1;
    if (pfnIoctlsocket(udpSocket, 0x8004667E, &mode) != 0) {
        Trace("steering ECU: Failed to set non-blocking mode");
        pfnClosesocket(udpSocket);
        pfnWSACleanup();
        FreeLibrary(hWs2_32);
        return false;
    }
    
    MySockAddr addr;
    memset(&addr, 0, sizeof(addr));
    addr.family = 2;
    addr.port = pfnHtons(5104);
    addr.addr = 0;
    
    if (pfnBind(udpSocket, &addr, sizeof(addr)) != 0) {
        Trace("steering ECU: Bind to port 5104 failed");
        pfnClosesocket(udpSocket);
        pfnWSACleanup();
        FreeLibrary(hWs2_32);
        return false;
    }
    
    Trace("steering ECU: UDP socket bound to port 5104");
    return true;
}

/* Convert big-endian float to CAN standard format */
float NetworkToHostFloat(unsigned char* bytes)
{
    unsigned char swapped[4];
    swapped[0] = bytes[3];
    swapped[1] = bytes[2];
    swapped[2] = bytes[1];
    swapped[3] = bytes[0];
    
    float result;
    memcpy(&result, swapped, 4);
    return result;
}

/* Start BUSMASTER generated function - OnDLL_Load */
void OnDLL_Load()
{
    Trace("steering ECU: Loading...");
    
    if (!InitUDP()) {
        Trace("steering ECU: ERROR - Failed to initialize UDP!");
    } else {
        Trace("steering ECU: Ready, waiting for CARLA data on port 5104");
    }
}
/* End BUSMASTER generated function - OnDLL_Load */

/* Start BUSMASTER generated function - OnDLL_Unload */
void OnDLL_Unload()
{
    if (udpSocket && pfnClosesocket) {
        pfnClosesocket(udpSocket);
    }
    if (pfnWSACleanup) {
        pfnWSACleanup();
    }
    if (hWs2_32) {
        FreeLibrary(hWs2_32);
    }
    Trace("steering ECU: Unloaded");
}
/* End BUSMASTER generated function - OnDLL_Unload */

/* Start BUSMASTER generated function - OnTimer_steeringTransmit_10 */
void OnTimer_steeringTransmit_10()
{
    if (!udpSocket || !pfnRecvfrom) {
        return;
    }
    
    char buffer[256];
    MySockAddr from;
    int fromLen = sizeof(from);
    
    /* Only process if we receive data */
    int received = pfnRecvfrom(udpSocket, buffer, sizeof(buffer), 0, 
                               &from, &fromLen);
    
    if (received >= 4) {
        /* Convert from network byte order */
        float steering = NetworkToHostFloat((unsigned char*)buffer);
        
        /* Set signal value - copy float bytes directly */
        UINT32 steeringValue;
        memcpy(&steeringValue, &steering, 4);
        steeringMsg.steering_current = steeringValue;
        
        /* Send CAN message */
        SendMsg(steeringMsg);
        
        messageCount++;
        Trace("steering ECU: RX %.2f km/h -> TX CAN ID=0x127 Data=[%02X %02X %02X %02X]", 
              steering,
              (steeringValue) & 0xFF,
              (steeringValue >> 8) & 0xFF,
              (steeringValue >> 16) & 0xFF,
              (steeringValue >> 24) & 0xFF);
    }
    /* If no data received, do nothing - no transmission */
}
/* End BUSMASTER generated function - OnTimer_steeringTransmit_10 */